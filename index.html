<html>
<head>
<title> Project 2 </title>
<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
body { font-family: Segoe UI; background: linear-gradient(to bottom, #2e76a5, #e8fffd);}
svg {padding : 10px;}
</style>
</head>
<body>
<div style = "width: 100%; margin-left: 10px">
  <h1 style = "font-weight: 900; font-size: 36px; margin-bottom: 5px">Comparison of City Skylines</h3>
  <div style = "float: left; width:50%">
    <h2 id="cityHeadingLeft" style = "font-weight: 800; font-size: 28px; margin-bottom: 0px">Seattle</h1>
    <svg width="550" height="300" id="leftSvg" style = "margin-bottom: -20px"></svg>
    <p id = "leftPop" style = "font-weight: 700; font-size: 20px" >Population: </p>
    <p>City: 
      <select id = "dropdownLeft" onchange = "selectData(value, true)" style = "border: none">
        <option value = "Chicago">Chicago</option>
        <option value = "Phoenix">Phoenix</option>
        <option value = "Seattle" selected>Seattle</option>
      </select>
    </p>
  </div>
  <div style = "float: right; width:50%">
    <h2 id="cityHeadingRight" style = "font-weight: 800; font-size: 28px; margin-bottom: 0px">Chicago</h1>
    <svg width="550", height="300", id="rightSvg"; style = "margin-bottom: -20px"></svg>
    <p id = "rightPop" style = "font-weight: 700; font-size: 20px">Population: </p>
    <p>City: 
    <select id = "dropdownRight" onchange = "selectData(value, false)" style = "border: none">
      <option value = "Chicago" selected>Chicago</option>
      <option value = "Phoenix">Phoenix</option>
      <option value = "Seattle">Seattle</option>
    </select>
    </p>
  </div>
</div>
<div style = "width:45%; margin:auto">
  Year: <input id="year" oninput="slide()" type="range" min="1880" max="2018" value="1880" 
  style="width: 500px; background: transparent; outline: none;">
  <br>
  <div style = "width:20%; margin:auto">
    <button type="button" onclick="show()" 
    style = "background-color: transparent; color: black; text-align: center; font-size: 16px; 
    border: 2px solid black; padding: 10px 24px; font-weight:700">
    Animate!</button>
  </div>
  </p>
</div>
<script>

var heights_array = [] // array (length 40) of the final heights of each building
var heights_array2 = []
var priority_order = [] // array (length 5) of the order that the buildings will be filled in for each height bracket
var priority_order2 = []
var building_data = [] // the csv data
var building_data_2 = []
var height_added1 = [] // array (length 5) of the heights added each time a building of a particular height brakcet is built
var height_added2 = []
var padding = 50;
var height = 250;
var width = 500;
var NO_BUILDINGS = 40; // number of buildings in the final skyline
var current_heights1 = []; // array (length 40) to keep track of the current heights of the buildings in the svg during animation
var current_heights2 = [];

var population_data1 = [];
var population_data2 = [];

var year_color = "#c5d7e5";

// Create a plot
var svg = d3.select("#leftSvg");
var svg2 = d3.select("#rightSvg");

// scale from building height to svg height
var heightScale = d3.scaleLinear()
.domain([2000,0])
.range([height,0]);

var yScale = d3.scaleLinear()
.domain([0,2000])
.range([height,0]);

svg.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
.call(d3.axisLeft(yScale));

svg.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");

svg.append("text").attr("transform", "translate(" + (width/2+padding) + "," + 2*padding+")").text("1880")
  .style("font-size", "150px")
  .style("fill", year_color)
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText");

svg2.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
.call(d3.axisLeft(yScale));

svg2.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");

svg2.append("text").attr("transform", "translate(" + (width/2+padding) + "," + 2*padding+")").text("1880")
  .style("font-size", "150px")
  .style("fill", year_color)
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText2");

selectData("seattle", true);
selectData("chicago", false);

 /**
 * Randomize array element order in-place.
 * Function taken from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 */
function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

// function to determine the height bracket that a given building is in 
// NEED TO UPDATE SO THIS CHANGES FOR DIFFERENT CITIES
function determineBucket(height){
	if (height > 530){
  		return 0;
  	}
  	else if (height > 330){
  		return 1;
  	}
  	else if (height > 260){
  		return 2;
  	}
  	else if (height > 190){
  		return 3;
  	}
  	else {
  		return 4;
  	}
}

// get rid of letters in number fields
function mutateRow(row) {
  row["Year"] = Number(row["Year"]);
  row["Height"] = row["Height"].replace(/\D/g, '');
  return row;
}

// convert year to a number
function mutatePop(row) {
  row["Year"] = Number(row["Year"]);
  return row;
}

function callback(data, left) {
  if(left) {
    svg.selectAll("rect").remove();
    document.getElementById("leftPop").innerHTML = "Population: "
    height_added1 = [];
  }else {
    svg2.selectAll("rect").remove();
    document.getElementById("rightPop").innerHTML = "Population: "
    height_added2 = [];
  }

  data = data.filter(function(d) { return d.Year > 0;});

  var buckets = [0,0,0,0,0]; // to determine number of buildings that fall into each height bracket
  var buckets2 = [0,0,0,0,0]; // used to generate the heights_added global array

  // iterate through data and determine the number of buildings in each height bracket
  for (var x = 0; x < data.length; x++){
  		buckets[determineBucket(data[x].Height)] += 1
  }

  // Determine the number of buildings to be constructed in the svg for each height bracket
	// MAY HAVE TO INCLUDE SOMETHING HERE TO ADJUST NUMBER OF BUILDINGS IF THEY DON'T ADD TO NO_BUILDINGS
  for (var y = 0; y < 5; y++){
  	buckets2[y] = Math.round(buckets[y] * NO_BUILDINGS / data.length);
  }

  var heights = [] //used to generate the heights_array global array

  // this section of code assigns each position in the svg to a specific height bracket, 
  // determines the eventual height of the building in that position
  // and stores this value in heights array
  data = data.sort(function(a, b) { 
    return b.Height - a.Height;
	});

  for (var y = 0; y < 5; y++){
  	sum_previous = 0;
  	for (var z = 0; z < y; z++){
  		sum_previous += buckets[z];
  	}
  	marker = sum_previous;
  	for (var j = 0; j < buckets2[y]; j++){
  		heights.push(Number(data[marker].Height));
  		marker += Math.floor(buckets[y]/buckets2[y]);
  	}
  }

  // randomize the locations of the buildings in the svg
  shuffleArray(heights);

  var p = [[],[],[],[],[]]; // used to generate the priority_order global array
  var sums = [0,0,0,0,0]; // an array keeping track of the sums of the heights of the buildings for each height bracket

  // add the svg building positions to the appropriate height bracket in p
	for (var z = 0; z < NO_BUILDINGS; z++){
		var b = determineBucket(heights[z]);
		p[b].push(z);
		sums[b] += heights[z];
	}
	// randomize the order that the buildings will be built
	for (var y = 0; y < 5; y++){
		shuffleArray(p[y]);
	}
  if(left) {
	// set the global arrays to their correct values
    for (var y = 0; y < 5; y++){
		  height_added1.push(sums[y] / buckets[y]);
    }
    heights_array = heights;
    priority_order = p;
    // sort the data by year and store it in the global array
    building_data = data.sort(function(a, b) { 
    return a.Year - b.Year;
    });
  }else {
    for (var y = 0; y < 5; y++){
      height_added2.push(sums[y] / buckets[y]);
    }
    heights_array2 = heights;
    priority_order2 = p;
    building_data2 = data.sort(function(a, b) { 
    return a.Year - b.Year;
    });
  } 
}  

// create object that tracks population of a city for a given year
function expandPopData(data) {
  var expandedPop = {};
  var i = 1880;
  var j = data.length-1;
  var prevPop = 0;
  while(i < 2019) {
    var key = "" + i;
    if(typeof(data[j]) === "undefined") {
      expandedPop[i] = data[0].Population;
    }else if(i === data[j].Year) {
      prevPop = data[j].Population;
      expandedPop[i] = data[j].Population;
      j--;
    }else if(i > data[j].Year) {
      if(j == data.length-1) {
        while (i > data[j].Year) {
          j--;
        }
        prevPop = data[j].Population;
        j--;
      }
      expandedPop[i] = prevPop;
    }else if (i < data[data.length-1].Year) {
      expandedPop[i] = "NA";
    }
    else{
      expandedPop[i] = prevPop;
    }
    i++;
  }
  return expandedPop;
}

// initializes data structures for a selected city
function selectData(city, left) {
  if (left) {
    d3.csv("" + city.toLowerCase() +".csv", mutateRow, function(error, data) {
      callback(data, left);
    });
    d3.csv("" + city.toLowerCase() + "Population.csv", mutatePop, function(error, data) {
        population_data1 = expandPopData(data);
      });
    document.getElementById("cityHeadingLeft").innerText = document.getElementById("dropdownLeft").value;
  }else {
    d3.csv("" + city.toLowerCase() +".csv", mutateRow, function(error, data) {
      callback(data, left);
    });
    d3.csv("" + city.toLowerCase() + "Population.csv", mutatePop, function(error, data) {
        population_data2 = expandPopData(data);
      });
    document.getElementById("cityHeadingRight").innerText = document.getElementById("dropdownRight").value;
  }
}

function fallBuildings(display, year, heights, priorities, data, current_heights, height_added){
  var svg = display;
	// only use the buildings built in the inputted year
	var dataset = data.filter(function(d) { return d.Year == year})

	if (dataset == false){
		return;
	}

	// iterate through the data
	for (var x = 0; x < dataset.length; x++){

		var bucket = determineBucket(dataset[x].Height);

		// this block of code determines the svg position of the building that will be added to (the "num" variable) 
		var building_number = 0
		while (current_heights[priorities[bucket][building_number]] >= heights[priorities[bucket][building_number]] - 5){
			building_number += 1;
		}
		var num = priorities[bucket][building_number];

		// if the building being added to will not be finished on this construction, simply add a rectangle to that building
		if (heights[num] - current_heights[num] >= height_added[bucket]){
			// update the current_heights array 
			current_heights[num] += height_added[bucket];

			var bar = svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", -heightScale(current_heights[num]))
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_added[bucket]))
    	.attr("fill", "transparent");

    	bar.transition().duration(500)
  		.attr("y", height - heightScale(current_heights[num]) + padding/2)
  		.style("fill", "black")
		}
		// if the building being added to will be finished on this construction, we need to also begin adding to a new building
		else {

			// determine how much height will still need to be added after finishing construction on the current building
			var height_leftover = height_added[bucket] - (heights[num] - current_heights[num]);

			// update the current_heights array to indicate that this building is finished
			current_heights[num] = heights[num];

			var bar2 = svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", -heightScale(heights[num]))
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(heights[num] - current_heights[num]))
    	.attr("fill", "transparent");

    	bar2.transition().duration(500)
  		.attr("y", height - heightScale(current_heights[num]) + padding/2)
  		.style("fill", "black")

    	// go to the next building that needs to begin construction
    	building_number += 1;
    	num2 = priorities[bucket][building_number];

    	current_heights[num2] += height_leftover;

			var bar3 = svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num2 + padding)
    	.attr("y", -heightScale(current_heights[num2]))
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_leftover))
    	.attr("fill", "transparent"); 

    	bar3.transition().duration(500)
  		.attr("y", height - heightScale(current_heights[num2]) + padding/2)
  		.style("fill", "black") 
		}
    
	}

}

function drawBuildings(display, year, heights, priorities, data, current_heights, height_added){
  var svg = display;
  // only use the buildings built before the inputted year
	var dataset = data.filter(function(d) { return d.Year <= year})

	// iterate through the data
	for (var x = 0; x < dataset.length; x++){
		var bucket = determineBucket(dataset[x].Height);
		// this block of code determines the svg position of the building that will be added to (the "num" variable) 
		var building_number = 0
		while (current_heights[priorities[bucket][building_number]] >= heights[priorities[bucket][building_number]] - 5){
			building_number += 1;
		}
		var num = priorities[bucket][building_number];
		// if the building being added to will not be finished on this construction, simply add a rectangle to that building
		if (heights[num] - current_heights[num] >= height_added[bucket]){
			// update the current_heights array 
			current_heights[num] += height_added[bucket];
			svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", height - heightScale(current_heights[num]) + padding/2)
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_added[bucket]))
    	.attr("fill", "black");    	
		}
		// if the building being added to will be finished on this construction, we need to also begin adding to a new building
		else {
			// determine how much height will still need to be added after finishing construction on the current building
			var height_leftover = height_added[bucket] - (heights[num] - current_heights[num]);
			
			// update the current_heights array to indicate that this building is finished
			current_heights[num] = heights[num];
			svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", height - heightScale(heights[num]) + padding/2)
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(heights[num] - current_heights[num]))
    	.attr("fill", "black");
    	// go to the next building that needs to begin construction
    	building_number += 1;
    	num2 = priorities[bucket][building_number];
    	current_heights[num2] += height_leftover;
			svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num2 + padding)
    	.attr("y", height - heightScale(current_heights[num2]) + padding/2)
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_leftover))
    	.attr("fill", "black");  
		}
    
	}
}

var i = 1904;                     //  set your counter to 1

function animate() {           //  create a loop function
   setTimeout(function () {    //  call a 3s setTimeout when the loop is called
      fallBuildings(svg, i, heights_array, priority_order, building_data, current_heights1, height_added1);     
      fallBuildings(svg2, i, heights_array2, priority_order2, building_data2, current_heights2, height_added2);     
      //document.getElementById("date").innerHTML = i;
      document.getElementById("year").value = i;
      d3.select("#yearText").text(""+i);
      d3.select("#yearText2").text(""+i);
      document.getElementById("leftPop").innerHTML = "Population: " +population_data1["" + i];
      document.getElementById("rightPop").innerHTML = "Population: " + population_data2["" + i];
      //document.getElementById("buildings").innerHTML = 
  //"# of High Rises: " + building_data.filter(function(d) { return d.Year <= i}).length;
      i++;                     //  increment the counter
      if (i < 2019) {            //  if the counter < 10, call the loop function
         animate();             //  ..  again which will trigger another 
      }                        //  ..  setTimeout()
   }, 100)
}

function show(){
	svg.selectAll("*").remove();
	svg.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
	.call(d3.axisLeft(yScale));
	svg.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");
	i = 1904;    
  svg.append("text").attr("transform", "translate(" + (padding+width/2) + "," + 2*padding+")").text(""+i)
  .style("font-size", "150px")
  .style("fill", year_color)
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText");
	current_heights1 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

  svg2.selectAll("*").remove();
  svg2.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
  .call(d3.axisLeft(yScale));
  svg2.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");
  i = 1904;    
  svg2.append("text").attr("transform", "translate(" + (padding+width/2) + "," + 2*padding+")").text(""+i)
  .style("font-size", "150px")
  .style("fill", year_color)
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText2");
  current_heights2 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

  document.getElementById("leftPop").innerHTML += population_data1["1880"];
  document.getElementById("rightPop").innerHTML += population_data2["1880"];

	animate();
}

function slide(){
	svg.selectAll("*").remove();
	svg.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
	.call(d3.axisLeft(yScale));
	svg.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");
	current_heights1 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  //document.getElementById("date").innerHTML = document.getElementById("year").value;
  svg.append("text").attr("transform", "translate(" + (padding+width/2) + "," + 2*padding+")").text(""+document.getElementById("year").value)
  .style("font-size", "150px")
  .style("fill", year_color)
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText");
  drawBuildings(svg, document.getElementById("year").value, heights_array, priority_order, building_data, current_heights1, height_added1);
  //yearText.text = document.getElementById("year").value;
  //document.getElementById("buildings").innerHTML = "# of High Rises: " + building_data.filter(function(d) { return d.Year <= document.getElementById("year").value}).length;
    svg2.selectAll("*").remove();
  svg2.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
  .call(d3.axisLeft(yScale));
  svg2.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");
  current_heights2 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  //document.getElementById("date").innerHTML = document.getElementById("year").value;
  svg2.append("text").attr("transform", "translate(" + (padding+width/2) + "," + 2*padding+")").text(""+document.getElementById("year").value)
  .style("font-size", "150px")
  .style("fill", year_color)
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText2");
  drawBuildings(svg2, document.getElementById("year").value, heights_array2, priority_order2, building_data2, current_heights2, height_added2);

  document.getElementById("leftPop").innerHTML = "Population: " + population_data1["" + document.getElementById("year").value];
  document.getElementById("rightPop").innerHTML = "Population: " + population_data2["" + document.getElementById("year").value];
}

</script>
</body>
</html>
