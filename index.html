<html>
<head>
<title> Project 2 </title>
<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">
<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
body { font-family: Segoe UI; }
</style>
</head>
<body>
<h1> Seattle </h1>
<svg width="550", height="300"></svg>
<script>

var heights_array = [] // array (length 40) of the final heights of each building
var priority_order = [] // array (length 5) of the order that the buildings will be filled in for each height bracket
var building_data = [] // the csv data
var height_added = [] // array (length 5) of the heights added each time a building of a particular height brakcet is built
var padding = 50;
var height = 250;
var width = 500;
var NO_BUILDINGS = 40; // number of buildings in the final skyline
var current_heights = []; // array (length 40) to keep track of the current heights of the buildings in the svg during animation

// Create a plot
var svg = d3.select("svg")

// scale from building height to svg height
var heightScale = d3.scaleLinear()
.domain([2000,0])
.range([height,0]);

var yScale = d3.scaleLinear()
.domain([0,2000])
.range([height,0]);

svg.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
.call(d3.axisLeft(yScale));

svg.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");

svg.append("text").attr("transform", "translate(" + (width/2+padding) + "," + 2*padding+")").text("1880")
  .style("font-size", "150px")
  .style("fill", "#bcbcbc")
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText");

 /**
 * Randomize array element order in-place.
 * Function taken from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 */
function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

// function to determine the height bracket that a given building is in 
// NEED TO UPDATE SO THIS CHANGES FOR DIFFERENT CITIES
function determineBucket(height){
	if (height > 530){
  		return 0;
  	}
  	else if (height > 330){
  		return 1;
  	}
  	else if (height > 260){
  		return 2;
  	}
  	else if (height > 190){
  		return 3;
  	}
  	else {
  		return 4;
  	}
}

// get rid of letters in number fields
function mutateRow(row) {
  row["Year"] = Number(row["Year"])
  row["Height"] = row["Height"].replace(/\D/g, '');
  return row;
}

function callback(error, data) {
  data = data.filter(function(d) { return d.Year > 0})

  var buckets = [0,0,0,0,0]; // to determine number of buildings that fall into each height bracket
  var buckets2 = [0,0,0,0,0]; // used to generate the heights_added global array

  // iterate through data and determine the number of buildings in each height bracket
  for (var x = 0; x < data.length; x++){
  		buckets[determineBucket(data[x].Height)] += 1
  }

  // Determine the number of buildings to be constructed in the svg for each height bracket
	// MAY HAVE TO INCLUDE SOMETHING HERE TO ADJUST NUMBER OF BUILDINGS IF THEY DON'T ADD TO NO_BUILDINGS
  for (var y = 0; y < 5; y++){
  	buckets2[y] = Math.round(buckets[y] * NO_BUILDINGS / data.length);
  }

  var heights = [] //used to generate the heights_array global array

  // this section of code assigns each position in the svg to a specific height bracket, 
  // determines the eventual height of the building in that position
  // and stores this value in heights array
  data = data.sort(function(a, b) { 
    return b.Height - a.Height;
	});

  for (var y = 0; y < 5; y++){
  	sum_previous = 0;
  	for (var z = 0; z < y; z++){
  		sum_previous += buckets[z];
  	}
  	marker = sum_previous;
  	for (var j = 0; j < buckets2[y]; j++){
  		heights.push(Number(data[marker].Height));
  		marker += Math.floor(buckets[y]/buckets2[y]);
  	}
  }

  // randomize the locations of the buildings in the svg
  shuffleArray(heights);

  var p = [[],[],[],[],[]]; // used to generate the priority_order global array
  var sums = [0,0,0,0,0]; // an array keeping track of the sums of the heights of the buildings for each height bracket

  // add the svg building positions to the appropriate height bracket in p
	for (var z = 0; z < NO_BUILDINGS; z++){
		var b = determineBucket(heights[z]);
		p[b].push(z);
		sums[b] += heights[z];
	}
	// randomize the order that the buildings will be built
	for (var y = 0; y < 5; y++){
		shuffleArray(p[y]);
	}

	// set the global arrays to their correct values
	for (var y = 0; y < 5; y++){
		height_added.push(sums[y] / buckets[y]);
	}
	heights_array = heights;
	priority_order = p; 
	// sort the data by year and store it in the global array
	building_data = data.sort(function(a, b) { 
    return a.Year - b.Year;
	});
}  

d3.csv("seattle.csv", mutateRow, callback);

function fallBuildings(year, heights, priorities, data){

	// only use the buildings built in the inputted year
	dataset = data.filter(function(d) { return d.Year == year})

	if (dataset == false){
		return;
	}

	// iterate through the data
	for (var x = 0; x < dataset.length; x++){

		var bucket = determineBucket(dataset[x].Height);

		// this block of code determines the svg position of the building that will be added to (the "num" variable) 
		var building_number = 0
		while (current_heights[priorities[bucket][building_number]] >= heights[priorities[bucket][building_number]] - 5){
			building_number += 1;
		}
		var num = priorities[bucket][building_number];

		// if the building being added to will not be finished on this construction, simply add a rectangle to that building
		if (heights[num] - current_heights[num] >= height_added[bucket]){
			// update the current_heights array 
			current_heights[num] += height_added[bucket];

			var bar = svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", -heightScale(current_heights[num]))
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_added[bucket]))
    	.attr("fill", "white");  

    	bar.transition().duration(500)
  		.attr("y", height - heightScale(current_heights[num]) + padding/2)
  		.style("fill", "black")
		}
		// if the building being added to will be finished on this construction, we need to also begin adding to a new building
		else {

			// determine how much height will still need to be added after finishing construction on the current building
			var height_leftover = height_added[bucket] - (heights[num] - current_heights[num]);

			// update the current_heights array to indicate that this building is finished
			current_heights[num] = heights[num];

			var bar2 = svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", -heightScale(heights[num]))
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(heights[num] - current_heights[num]))
    	.attr("fill", "white");

    	bar2.transition().duration(500)
  		.attr("y", height - heightScale(current_heights[num]) + padding/2)
  		.style("fill", "black")

    	// go to the next building that needs to begin construction
    	building_number += 1;
    	num2 = priorities[bucket][building_number];

    	current_heights[num2] += height_leftover;

			var bar3 = svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num2 + padding)
    	.attr("y", -heightScale(current_heights[num2]))
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_leftover))
    	.attr("fill", "white"); 

    	bar3.transition().duration(500)
  		.attr("y", height - heightScale(current_heights[num2]) + padding/2)
  		.style("fill", "black") 
		}
    
	}

}

function drawBuildings(year, heights, priorities, data){
	// only use the buildings built before the inputted year
	dataset = data.filter(function(d) { return d.Year <= year})

	// iterate through the data
	for (var x = 0; x < dataset.length; x++){
		var bucket = determineBucket(dataset[x].Height);
		// this block of code determines the svg position of the building that will be added to (the "num" variable) 
		var building_number = 0
		while (current_heights[priorities[bucket][building_number]] >= heights[priorities[bucket][building_number]] - 5){
			building_number += 1;
		}
		var num = priorities[bucket][building_number];
		// if the building being added to will not be finished on this construction, simply add a rectangle to that building
		if (heights[num] - current_heights[num] >= height_added[bucket]){
			// update the current_heights array 
			current_heights[num] += height_added[bucket];
			svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", height - heightScale(current_heights[num]) + padding/2)
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_added[bucket]))
    	.attr("fill", "black");    	
		}
		// if the building being added to will be finished on this construction, we need to also begin adding to a new building
		else {
			// determine how much height will still need to be added after finishing construction on the current building
			var height_leftover = height_added[bucket] - (heights[num] - current_heights[num]);
			
			// update the current_heights array to indicate that this building is finished
			current_heights[num] = heights[num];
			svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num + padding)
    	.attr("y", height - heightScale(heights[num]) + padding/2)
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(heights[num] - current_heights[num]))
    	.attr("fill", "black");
    	// go to the next building that needs to begin construction
    	building_number += 1;
    	num2 = priorities[bucket][building_number];
    	current_heights[num2] += height_leftover;
			svg.append("rect")
    	.attr("x", (width / NO_BUILDINGS) * num2 + padding)
    	.attr("y", height - heightScale(current_heights[num2]) + padding/2)
    	.attr("width", width / NO_BUILDINGS)
    	.attr("height", heightScale(height_leftover))
    	.attr("fill", "black");  
		}
    
	}
}

var i = 1904;                     //  set your counter to 1

function animate() {           //  create a loop function
   setTimeout(function () {    //  call a 3s setTimeout when the loop is called
      fallBuildings(i, heights_array, priority_order, building_data);          
      document.getElementById("date").innerHTML = i;
      document.getElementById("year").value = i;
      d3.select("#yearText").text(""+i);
      //document.getElementById("buildings").innerHTML = 
  "# of High Rises: " + building_data.filter(function(d) { return d.Year <= i}).length;
      i++;                     //  increment the counter
      if (i < 2019) {            //  if the counter < 10, call the loop function
         animate();             //  ..  again which will trigger another 
      }                        //  ..  setTimeout()
   }, 100)
}

function show(){
	svg.selectAll("*").remove();
	svg.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
	.call(d3.axisLeft(yScale));
	svg.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");
	i = 1904;    
  svg.append("text").attr("transform", "translate(" + (padding+width/2) + "," + 2*padding+")").text(""+i)
  .style("font-size", "150px")
  .style("fill", "#bcbcbc")
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText");
	current_heights = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
	animate();
}

function slide(){
	svg.selectAll("*").remove();
	svg.append("g").attr("transform", "translate(" + padding + "," + padding / 2 + ")")
	.call(d3.axisLeft(yScale));
	svg.append("text").attr("transform", "rotate(270) translate(-170, 12)").text("Height");
	current_heights = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
	drawBuildings(document.getElementById("year").value, heights_array, priority_order, building_data);
  document.getElementById("date").innerHTML = document.getElementById("year").value;
  svg.append("text").attr("transform", "translate(" + (padding+width/2) + "," + 2*padding+")").text(""+document.getElementById("year").value)
  .style("font-size", "150px")
  .style("fill", "#bcbcbc")
  .style("font-weight", 900)
  .style("text-anchor", "middle")
  .style("dominant-baseline", "central")
  .attr("id", "yearText");
  //yearText.text = document.getElementById("year").value;
  //document.getElementById("buildings").innerHTML = "# of High Rises: " + building_data.filter(function(d) { return d.Year <= document.getElementById("year").value}).length;
}

	

</script>
<br><br>
<button type="button" onclick="show()">Animate!</button><br><br>
Year: <input id="year" oninput="slide()" type="range" min="1880" max="2018" value="1880" style="width: 500px">
<p id="date" style="font-size:20px;">1880</p>
<!-- <p id="buildings" style="font-size:20px;"># of High Rises: 0</p> -->



</body>
</html>
